#include <duke/engine/Buffer3D.hpp>

namespace duke {

  //Buffer3D to store and bind the texture generated by the OpenColorIOManager object

  Buffer3D::Buffer3D(uint size){   
    typedef float ComponentType;// GL_UNSIGNED_BYTE or GL_FLOAT ?
    this->nbChannel=3; // GL_RGB
    this->nbSamplePerChannel=32; // Resolved at creation, generally 16 or 32
    this->rawBuffer = new ComponentType[nbChannel*size*size*size];

    Buffer3D::createIDLut(size, rawBuffer); 
  } 

  Buffer3D::~Buffer3D() {
    if (rawBuffer) 
      delete [] rawBuffer;
  }
  
  void Buffer3D::uploadTo(gl::GlTexture3D &tex, uint textID) {
	
    GLint memID;
        glGetIntegerv(GL_ACTIVE_TEXTURE, &memID);
	switch(textID)
	  {
	  case '1':
	    glActiveTexture(GL_TEXTURE1);
	    break;
	  case '2':
	    glActiveTexture(GL_TEXTURE2);
	     break;	
	  case '3':
	    glActiveTexture(GL_TEXTURE3);
	    break;
	  default:
	    glActiveTexture(GL_TEXTURE0);
	    break;
   
	  }

	//glEnable(GL_TEXTURE_3D);
	auto textureBound = tex.scope_bind_texture();
	// Interpolation ?
	glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	// Initialize the bounds of the 3d texture
	glTexImage3D(GL_TEXTURE_3D, 0, GL_RGB, 
		     nbSamplePerChannel, nbSamplePerChannel, nbSamplePerChannel, 
		     0, GL_RGB, GL_FLOAT, &rawBuffer[0]);//TODO if not rgb or float
        glActiveTexture(memID);
  }


  void Buffer3D::createIDLut(uint size, ComponentType *rawBuffer) {//create identity lut

    // Precompute the inverse of the size
    float invSizef = float(1. / ( size - 1. ));
    // Pull the colors on the LUT - RGB
    for(uint i = 0; i < size * size * size; i++)
        {
            *rawBuffer++ = (float)(i%size) * invSizef;
            *rawBuffer++ = (float)((i/size)%size) * invSizef;
            *rawBuffer++ = (float)((i/size/size)%size) * invSizef;
        }	
  }
 

};//namespace duke
